menu "CPU Frequency scaling"

config CPU_FREQ
	bool "CPU Frequency scaling"
	help
	  CPU Frequency scaling allows you to change the clock speed of 
	  CPUs on the fly. This is a nice method to save power, because 
	  the lower the CPU clock speed, the less power the CPU consumes.

	  Note that this driver doesn't automatically change the CPU
	  clock speed, you need to either enable a dynamic cpufreq governor
	  (see below) after boot, or use a userspace tool.

	  For details, take a look at <file:Documentation/cpu-freq>.

	  If in doubt, say N.

if CPU_FREQ

config CPU_FREQ_GOV_COMMON
	bool

config CPU_FREQ_BOOST_SW
	bool
	depends on THERMAL

config CPU_FREQ_STAT
	tristate "CPU frequency translation statistics"
	default y
	help
	  This driver exports CPU frequency statistics information through sysfs
	  file system.

	  To compile this driver as a module, choose M here: the
	  module will be called cpufreq_stats.

	  If in doubt, say N.

config CPU_FREQ_STAT_DETAILS
	bool "CPU frequency translation statistics details"
	depends on CPU_FREQ_STAT
	help
	  This will show detail CPU frequency translation table in sysfs file
	  system.

	  If in doubt, say N.

choice
	prompt "Default CPUFreq governor"
	default CPU_FREQ_DEFAULT_GOV_USERSPACE if ARM_SA1100_CPUFREQ || ARM_SA1110_CPUFREQ
	default CPU_FREQ_DEFAULT_GOV_PERFORMANCE
	help
	  This option sets which CPUFreq governor shall be loaded at
	  startup. If in doubt, select 'performance'.

config CPU_FREQ_DEFAULT_GOV_ABYSSPLUG
	bool "abyssplug"
	select CPU_FREQ_GOV_ABYSSPLUG
	select CPU_FREQ_GOV_PERFORMANCE
	---help---
	  Use the CPUFreq governor 'abyssplug' as default. This allows you
	  to get a full dynamic frequency capable system with CPU
	  hotplug support by simply loading your cpufreq low-level
	  hardware driver.  Be aware that not all cpufreq drivers
	  support the hotplug governor. If unsure have a look at
	  the help section of the driver. Fallback governor will be the
	  performance governor.

config CPU_FREQ_DEFAULT_GOV_ABYSSPLUGV2
	bool "abyssplug"
	select CPU_FREQ_GOV_ABYSSPLUG
	select CPU_FREQ_GOV_PERFORMANCE
	---help---
	  Use the CPUFreq governor 'abyssplug' as default. This allows you
	  to get a full dynamic frequency capable system with CPU
	  hotplug support by simply loading your cpufreq low-level
	  hardware driver.  Be aware that not all cpufreq drivers
	  support the hotplug governor. If unsure have a look at
	  the help section of the driver. Fallback governor will be the
	  performance governor.

config CPU_FREQ_DEFAULT_GOV_ADAPTIVE
	bool "adaptive"
	select CPU_FREQ_GOV_ADAPTIVE
	---help---
	  Use the CPUFreq governor 'adaptive' as default. This allows
	  you to get a full dynamic cpu frequency capable system by simply
	  loading your cpufreq low-level hardware driver, using the
	  'adaptive' governor for latency-sensitive workloads and demanding
	  performance.

config CPU_FREQ_DEFAULT_GOV_ADAPTIVEX
	bool "adaptivex"
	select CPU_FREQ_GOV_ADAPTIVEX
	help
	  Use the CPUFreq governor 'adaptiveX' as default.
	  'adaptive' with suspend/wake and CPU hotplugging support.

config CPU_FREQ_DEFAULT_GOV_ARTERACTIVE
	bool "arteractive"
	select CPU_FREQ_GOV_ARTERACTIVE
	help
	  Use the CPUFreq governor 'arteractive' as default. This allows
	  you to get a full dynamic cpu frequency capable system by simply
	  loading your cpufreq low-level hardware driver, using the
	  'arteractive' governor for latency-sensitive workloads.

config CPU_FREQ_DEFAULT_GOV_ALUCARD
	bool "alucard"
	select CPU_FREQ_GOV_ALUCARD
	help

config CPU_FREQ_DEFAULT_GOV_ASSWAX
 	 bool "asswax"
  	 select CPU_FREQ_GOV_ASSWAX
  	 help
	  Use as default governor

config CPU_FREQ_DEFAULT_GOV_BADASS
	bool "badass"
	select CPU_FREQ_GOV_BADASS

config CPU_FREQ_DEFAULT_GOV_BALANCE
	bool "balance"
	select CPU_FREQ_GOV_BALANCE
	select CPU_FREQ_GOV_PERFORMANCE
	help
	  Use the CPUFreq governor 'balance' as default. This allows
	  you to get a full dynamic frequency capable system by simply
	  loading your cpufreq low-level hardware driver.
	  Be aware that not all cpufreq drivers support the balance
	  governor. If unsure have a look at the help section of the
	  driver. Fallback governor will be the performance governor.

config CPU_FREQ_DEFAULT_GOV_BARRY_ALLEN
	bool "barry_allen"
	select CPU_FREQ_GOV_BARRY_ALLEN
	help
	  Use the CPUFreq governor 'barry_allen' as default. This allows
	  you to get a full dynamic cpu frequency capable system by simply
	  loading your cpufreq low-level hardware driver, using the
	  'barry_allen' governor for latency-sensitive workloads.

config CPU_FREQ_DEFAULT_GOV_BIOSHOCK
	bool "BioShock"
	select CPU_FREQ_GOV_BIOSHOCK
	help
	  Default governor of BioShock kernel

config CPU_FREQ_DEFAULT_GOV_BLU_ACTIVE
	bool "blu_active"
	select CPU_FREQ_GOV_BLU_ACTIVE
	help
	  Use the CPUFreq governor 'blu_active' as default. This allows
	  you to get a full dynamic cpu frequency capable system by simply
	  loading your cpufreq low-level hardware driver, using the
	  'interactive' governor for latency-sensitive workloads.

config CPU_FREQ_DEFAULT_GOV_BLU_SCHEDUTIL
	bool "blu_schedutil"
	select CPU_FREQ_GOV_BLU_SCHEDUTIL
	select CPU_FREQ_GOV_PERFORMANCE
	help
	  Use the 'blu_schedutil' CPUFreq governor by default. If unsure,
	  have a look at the help section of that governor. The fallback
	  governor will be 'performance'.

config CPU_FREQ_DEFAULT_GOV_BOOSTACTIVE
	bool "boostactive"
	select CPU_FREQ_GOV_BOOSTACTIVE
	help
	  Use the CPUFreq governor 'boostactive' as default. This allows
	  you to get a full dynamic cpu frequency capable system by simply
	  loading your cpufreq low-level hardware driver, using the
	  'interactive' governor for latency-sensitive workloads.
	  
config CPU_FREQ_DEFAULT_GOV_BRAZILIANWAX
	bool "brazilianwax"
	select CPU_FREQ_GOV_BRAZILIANWAX
	---help---
	  Use the CPUFreq governor 'brazilianwax' as default. This allows
	  you to get a full dynamic cpu frequency capable system by simply
	  loading your cpufreq low-level hardware driver, using the
	  'brazilianwax' governor for latency-sensitive workloads and demanding
	  performance.	

config CPU_FREQ_DEFAULT_GOV_CAFACTIVE
	bool "cafactive"
	select CPU_FREQ_GOV_CAFACTIVE
	help
	  Use the CPUFreq governor 'cafactive' as default. This allows
	  you to get a full dynamic cpu frequency capable system by simply
	  loading your cpufreq low-level hardware driver, using the
	  'cafactive' governor for latency-sensitive workloads.

config CPU_FREQ_DEFAULT_GOV_CHILL
	bool "chill"
	select CPU_FREQ_GOV_CHILL
	select CPU_FREQ_GOV_INTERACTIVE
	help
	  Use the CPUFreq governor 'chill' as default. This allows
	  you to get a full dynamic frequency capable system by simply
	  loading your cpufreq low-level hardware driver.
	  Be aware that not all cpufreq drivers support the conservative
	  governor. If unsure have a look at the help section of the
	  driver. Fallback governor will be the interactive governor.

config CPU_FREQ_DEFAULT_GOV_CONSERVATIVE
	bool "conservative"
	select CPU_FREQ_GOV_CONSERVATIVE
	select CPU_FREQ_GOV_PERFORMANCE
	help
	  Use the CPUFreq governor 'conservative' as default. This allows
	  you to get a full dynamic frequency capable system by simply
	  loading your cpufreq low-level hardware driver.
	  Be aware that not all cpufreq drivers support the conservative
	  governor. If unsure have a look at the help section of the
	  driver. Fallback governor will be the performance governor.

config CPU_FREQ_DEFAULT_GOV_CLARITY
	bool "clarity"
	select CPU_FREQ_GOV_CLARITY
	help
	  Use the CPUFreq governor 'clarity' as default. This allows
	  you to get a full dynamic cpu frequency capable system by simply
	  loading your cpufreq low-level hardware driver, using the
	  'clarity' governor for latency-sensitive workloads.

config CPU_FREQ_DEFAULT_GOV_CULTIVATION
	bool "cultivation"
	select CPU_FREQ_GOV_CULTIVATION
	help
	Use the CPUFreq governor 'cultivation' as default.

config CPU_FREQ_DEFAULT_GOV_CYAN
	bool "conservative"
	select CPU_FREQ_GOV_CYAN
	help
		CYAN

config CPU_FREQ_DEFAULT_GOV_DANCEDANCE
            bool "dancedance"
            select CPU_FREQ_GOV_DANCEDANCE
            help
              Use the CPUFreq governor 'dancedance' as default.
	      
config CPU_FREQ_DEFAULT_GOV_DARKNESS
	bool "darkness"
	select CPU_FREQ_GOV_DARKNESS
	help
	  Use the CPUFreq governor 'Darkness' as default.

config CPU_FREQ_DEFAULT_GOV_ELECTRODEMAND
	bool "electrodemand"
	select CPU_FREQ_GOV_ELECTRODEMAND
        select CPU_FREQ_GOV_PERFORMANCE
	help
	  Use the CPUFreq governor 'electrodemand' as default. This allows
	  you to get a full dynamic cpu frequency capable system by simply
	  loading your cpufreq low-level hardware driver, using the
	  'electrodemand' governor for latency-sensitive workloads.

config CPU_FREQ_DEFAULT_GOV_ELECTRON
 	bool "electron"
 	select CPU_FREQ_GOV_ELECTRON
 	help
	  Use the CPUFreq governor 'electron' as default. This allows
	  you to get a full dynamic cpu frequency capable system by simply
	  loading your cpufreq low-level hardware driver, using the
	  'electron' governor for latency-sensitive workloads.

config CPU_FREQ_DEFAULT_GOV_ELEMENTALX
	bool "elementalx"
	select CPU_FREQ_GOV_ELEMENTALX
	select CPU_FREQ_GOV_PERFORMANCE
	help
	  Use the CPUFreq governor 'elementalx' as default.

config CPU_FREQ_DEFAULT_GOV_HOTPLUG
	bool "hotplug"
	select CPU_FREQ_GOV_HOTPLUG
	select CPU_FREQ_GOV_PERFORMANCE
	help
	  Use the CPUFreq governor 'hotplug' as default. This allows
	  you to get a full dynamic frequency capable system by simply
	  loading your cpufreq low-level hardware driver.
	  Be aware that not all cpufreq drivers support the hotplug
	  governor. If unsure have a look at the help section of the
	  driver. Fallback governor will be the performance governor.

config CPU_FREQ_DEFAULT_GOV_HELLSACTIVE
	bool "hellsactive"
	select CPU_FREQ_GOV_HELLSACTIVE
	help
	Use the CPUFreq governor 'hellsactive' as default. This allows
	you to get a full dynamic cpu frequency capable system by simply
	loading your cpufreq low-level hardware driver, using the
	'interactive' governor for latency-sensitive workloads.

config CPU_FREQ_DEFAULT_GOV_HYPER
	bool "HYPER"
	select CPU_FREQ_GOV_HYPER
	---help---
	  Use the CPUFreq governor 'HYPER' as default.

config CPU_FREQ_DEFAULT_GOV_HYPERX
        bool "HYPERX"
        select CPU_FREQ_GOV_HYPERX
        ---help---
          Use the CPUFreq governor 'HYPERX' as default.	

config CPU_FREQ_DEFAULT_GOV_IMPULSE
	bool "impulse"
	select CPU_FREQ_GOV_IMPULSE
	help
		Use the CPUFreq governor 'impulse' as default. This allows
		you to get a full dynamic cpu frequency capable system by simply
		loading your cpufreq low-level hardware driver, using the
		'impulse' governor for latency-sensitive workloads.

config CPU_FREQ_DEFAULT_GOV_INTELLIACTIVE
	bool "intelliactive"
	select CPU_FREQ_GOV_INTELLIACTIVE
	help
	  Use the CPUFreq governor 'intelliactive' as default. This allows
	  you to get a full dynamic cpu frequency capable system by simply
	  loading your cpufreq low-level hardware driver, using the
	  'interactive' governor for latency-sensitive workloads.

config CPU_FREQ_DEFAULT_GOV_INTELLIDEMAND
	bool "intellidemand"
	select CPU_FREQ_GOV_INTELLIDEMAND
	help
	  Use the CPUFreq governor 'intellidemand' as default. This is
	  based on Ondemand with browsing detection based on GPU loading

config CPU_FREQ_DEFAULT_GOV_INTELLIMM
       bool "intelliminmax"
       select CPU_FREQ_GOV_INTELLIMM
       help
         Use the CPUFreq governor 'intelliminmax' as default. This is
         governor will use only 3 different frequencies, idle, UI and max

config CPU_FREQ_DEFAULT_GOV_INTERACTIVE
	bool "interactive"
	select CPU_FREQ_GOV_INTERACTIVE
	help
	  Use the CPUFreq governor 'interactive' as default. This allows
	  you to get a full dynamic cpu frequency capable system by simply
	  loading your cpufreq low-level hardware driver, using the
	  'interactive' governor for latency-sensitive workloads.

config CPU_FREQ_DEFAULT_GOV_INTERACTIVEB
	bool "interactiveb"
	select CPU_FREQ_GOV_INTERACTIVEB
	help
	  Use the CPUFreq governor 'interactiveb' as default. This allows
          you to get a full dynamic cpu frequency capable system by simply
          loading your cpufreq low-level hardware driver, using the
	  'interactiveb' governor for latency-sensitive workloads.

config CPU_FREQ_DEFAULT_GOV_DYNAMIC_INTERACTIVE
	bool "dynamic_interactive"
	select CPU_FREQ_GOV_DYNAMIC_INTERACTIVE
	help
	  Use the CPUFreq governor 'dynamic interactive' as default. This allows
	  you to get a full dynamic cpu frequency capable system by simply
	  loading your cpufreq low-level hardware driver, using the
	  'dynamic_interactive' governor for latency-sensitive workloads.

config CPU_FREQ_DEFAULT_GOV_THUNDERSTORMS_INTERACTIVE
	bool "thunderstorms_interactive"
	select CPU_FREQ_GOV_THUNDERSTORMS_INTERACTIVE
	help
	  Use the CPUFreq governor 'thunderstorms interactive' as default. This allows
	  you to get a full dynamic cpu frequency capable system by simply
	  loading your cpufreq low-level hardware driver, using the
	  'thunderstorms_interactive' governor for latency-sensitive workloads.

config CPU_FREQ_DEFAULT_GOV_THUNDERSTORM
	bool "thunderstorm"
	select CPU_FREQ_GOV_THUNDERSTORM
	help
	  Use the CPUFreq governor 'thunderstorm' as default. This allows
	  you to get a full dynamic cpu frequency capable system by simply
	  loading your cpufreq low-level hardware driver, using the
	  'thunderstorm' governor for latency-sensitive workloads.

config CPU_FREQ_DEFAULT_GOV_IRONACTIVE
	bool "ironactive"
	select CPU_FREQ_GOV_IRONACTIVE
	help
	  Use the CPUFreq governor 'ironactive' as default. This cpugovernor
	  is based on the 'interactive' governor with many changes made by
	  CAF.

config CPU_FREQ_DEFAULT_GOV_NEBULA
	bool "interactive"
	select CPU_FREQ_GOV_NEBULA
	help

config CPU_FREQ_DEFAULT_GOV_INTEL
	bool "intel"
	select CPU_FREQ_GOV_INTEL
	help
	  Use the CPUFreq governor 'intel' as default. This allows
	  you to get a full dynamic cpu frequency capable system by simply
	  loading your cpufreq low-level hardware driver, using the
	  'intel' governor for better perfromance and power with Intel


config CPU_FREQ_DEFAULT_GOV_FRANKENSTEIN
	bool "frankenstein"
	select CPU_FREQ_GOV_frankenstein
	help
	  Use the CPUFreq governor 'frankenstein' as default. This allows
	  you to get a full dynamic cpu frequency capable system by simply
	  loading your cpufreq low-level hardware driver, using the
	  'frankenstein' governor for latency-sensitive workloads.

config CPU_FREQ_DEFAULT_GOV_KTOONSERVATIVEQ
	bool "ktoonservativeq"
	select CPU_FREQ_GOV_KTOONSERVATIVEQ
	select CPU_FREQ_GOV_PERFORMANCE
	help
	  Use the CPUFreq governor 'ktoonservativeq' as default. This allows
	  you to get a full dynamic frequency capable system by simply
	  loading your cpufreq low-level hardware driver.
	  Be aware that not all cpufreq drivers support the ktoonservativeq
	  governor. If unsure have a look at the help section of the
	  driver. Fallback governor will be the performance governor.  This
	  governor adds the capability of hotpluging.

#config CPU_FREQ_GOV_HYBRID
#	tristate "'hybrid' cpufreq policy governor"
#	select CPU_FREQ_TABLE
#	help
#	  'hybrid' - This driver adds a dynamic cpufreq policy governor.
#	  The governor does a periodic polling and 
#	  changes frequency based on the CPU utilization.
#	  The support for this governor depends on CPU capability to
#	  do fast frequency switching (i.e, very low latency frequency
#	  transitions). 

#	  To compile this driver as a module, choose M here: the
#	  module will be called cpufreq_hybrid.

#	  For details, take a look at linux/Documentation/cpu-freq.

#	  If in doubt, say N.

config CPU_FREQ_DEFAULT_GOV_HOTPLUG
	bool "hotplug"
	select CPU_FREQ_GOV_HOTPLUG
	select CPU_FREQ_GOV_PERFORMANCE
	help
	  Use the CPUFreq governor 'hotplug' as default. This allows
	  you to get a full dynamic frequency capable system by simply
	  loading your cpufreq low-level hardware driver.
	  Be aware that not all cpufreq drivers support the hotplug
	  governor. If unsure have a look at the help section of the
	  driver. Fallback governor will be the performance governor.

config CPU_FREQ_DEFAULT_GOV_HYBRID
	bool "hybrid"
	select CPU_FREQ_TABLE
	select CPU_FREQ_GOV_HYBRID
	select CPU_FREQ_GOV_PERFORMANCE
	help
	  Use the CPUFreq governor 'hybrid' as default. This allows
	  you to get a full dynamic frequency capable system by simply
	  loading your cpufreq low-level hardware driver.
	  Be aware that not all cpufreq drivers support the hybrid
	  governor. If unsure have a look at the help section of the
	  driver. Fallback governor will be the performance governor.

config CPU_FREQ_DEFAULT_GOV_LAZY
	bool "lazy"
	select CPU_FREQ_GOV_LAZY
	select CPU_FREQ_GOV_PERFORMANCE
	help
	  Use the CPUFreq governor 'lazy' as default.

config CPU_FREQ_DEFAULT_GOV_LAGFREE
        bool "lagfree"
        select CPU_FREQ_GOV_LAGFREE
        help
          Use the CPUFreq governor 'lagfree' as default. This allows
          you to get a full dynamic frequency capable system by simply
          loading your cpufreq low-level hardware driver.
          Be aware that not all cpufreq drivers support the lagfree
          governor. If unsure have a look at the help section of the
          driver. Fallback governor will be the performance governor.
	  
config CPU_FREQ_DEFAULT_GOV_LIONFISH
	bool "lionfish"
	select CPU_FREQ_GOV_LIONFISH
	help
	  Use the CPUFreq governor 'lionfish' as default.

config CPU_FREQ_DEFAULT_GOV_LIONHEART
	bool "lionheart"
	select CPU_FREQ_GOV_LIONHEART
	help
	  Use the CPUFreq governor 'lionheart' as default.

config CPU_FREQ_DEFAULT_GOV_LULZACTIVE
	bool "lulzactive"
	select CPU_FREQ_GOV_LULZACTIVE
	select CPU_FREQ_GOV_PERFORMANCE
	help
	  Use the CPUFreq governor 'lulzactive' as default.

config CPU_FREQ_DEFAULT_GOV_MYTHX_PLUG
	bool "mythx_plug"
	select CPU_FREQ_GOV_MYTHX_PLUG
	help

config CPU_FREQ_DEFAULT_GOV_NEXUS
	bool "nexus"
	select CPU_FREQ_GOV_NEXUS
	help
	  Use the CPUFreq governor 'nexus' as default.


config CPU_FREQ_DEFAULT_GOV_NIGHTMARE
	bool "nightmare"
	select CPU_FREQ_GOV_NIGHTMARE
	help
	  Use the CPUFreq governor 'Nightmare' as default.

config CPU_FREQ_DEFAULT_GOV_ONDEMAND
	bool "ondemand"
	select CPU_FREQ_GOV_ONDEMAND
	select CPU_FREQ_GOV_PERFORMANCE
	help
	  Use the CPUFreq governor 'ondemand' as default. This allows
	  you to get a full dynamic frequency capable system by simply
	  loading your cpufreq low-level hardware driver.
	  Be aware that not all cpufreq drivers support the ondemand
	  governor. If unsure have a look at the help section of the
	  driver. Fallback governor will be the performance governor.

config CPU_FREQ_DEFAULT_GOV_ONDEMANDPLUS
	bool "ondemandplus"
	select CPU_FREQ_GOV_ONDEMANDPLUS
	select CPU_FREQ_GOV_PERFORMANCE
	help
	  Use the CPUFreq governor 'ondemandplus' as default. This allows
	  you to get a full dynamic frequency capable system by simply
	  loading your cpufreq low-level hardware driver.
	  Be aware that not all cpufreq drivers support the ondemandplus
	  governor. If unsure have a look at the help section of the
	  driver. Fallback governor will be the performance governor.

config CPU_FREQ_DEFAULT_GOV_ONDEMAND_X
	bool "ondemand_x"
	select CPU_FREQ_GOV_ONDEMAND_X
	select CPU_FREQ_GOV_PERFORMANCE
	help
	  Use the CPUFreq governor 'ondemand_x' as default. This allows
	  you to get a full dynamic frequency capable system by simply
	  loading your cpufreq low-level hardware driver.
	  Be aware that not all cpufreq drivers support the ondemand_x
	  governor. If unsure have a look at the help section of the
	  driver. Fallback governor will be the performance governor.

config CPU_FREQ_DEFAULT_GOV_OPTIMAX
	bool "optimax"
	select CPU_FREQ_GOV_OPTIMAX
	select CPU_FREQ_GOV_PERFORMANCE
	help
	Use the CPUFreq governor 'optimax' as default

config CPU_FREQ_DEFAULT_GOV_PEGASUSQ
	bool "pegasusq"
	select CPU_FREQ_GOV_PEGASUSQ
	help
	  Use the CPUFreq governor 'pegasusq' as default.

config CPU_FREQ_DEFAULT_GOV_SCHEDUTIL
	bool "schedutil"
	depends on SMP
	select CPU_FREQ_GOV_SCHEDUTIL
	select CPU_FREQ_GOV_PERFORMANCE
	help
	  Use the 'schedutil' CPUFreq governor by default. If unsure,
	  have a look at the help section of that governor. The fallback
	  governor will be 'performance'.

config CPU_FREQ_DEFAULT_GOV_PERFORMANCE
	bool "performance"
	select CPU_FREQ_GOV_PERFORMANCE
	help
	  Use the CPUFreq governor 'performance' as default. This sets
	  the frequency statically to the highest frequency supported by
	  the CPU.

config CPU_FREQ_DEFAULT_GOV_POISON
  	bool "Poison"
  	select CPU_FREQ_GOV_POISON
  	help

config CPU_FREQ_DEFAULT_GOV_POWERSAVE
	bool "powersave"
	depends on EXPERT
	select CPU_FREQ_GOV_POWERSAVE
	help
	  Use the CPUFreq governor 'powersave' as default. This sets
	  the frequency statically to the lowest frequency supported by
	  the CPU.

config CPU_FREQ_DEFAULT_GOV_RELAXED
	bool "relaxed"
	select CPU_FREQ_GOV_RELAXED
	select CPU_FREQ_GOV_INTERACTIVE
	help
		Use the CPUFreq governor 'relaxed' as default. This allows
		you to get a full dynamic frequency capable system by simply
		loading your cpufreq low-level hardware driver.
		Be aware that not all cpufreq drivers support the conservative
		governor. If unsure have a look at the help section of the
		driver. Fallback governor will be the interactive governor.

config CPU_FREQ_DEFAULT_GOV_SCHED
	bool "sched"
	select CPU_FREQ_GOV_INTERACTIVE
	help
	  Use the CPUfreq governor 'sched' as default. This scales
	  cpu frequency using CPU utilization estimates from the
	  scheduler.

config CPU_FREQ_DEFAULT_GOV_SAVAGEDZEN
	bool "savagedzen"
	select CPU_FREQ_GOV_SAVAGEDZEN
	help
	  Use the CPUFreq governor 'savagedzen' as default.

config CPU_FREQ_DEFAULT_GOV_SMARTASS2
	bool "smartassV2"
	select CPU_FREQ_GOV_SMARTASS2
	help
	  Use the CPUFreq governor 'smartass2' as default.

config CPU_FREQ_DEFAULT_GOV_SMARTMAX
	bool "smartmax"
	select CPU_FREQ_GOV_SMARTMAX
	help

config CPU_FREQ_DEFAULT_GOV_SMARTMAX_EPS
	bool "smartmax_eps"
	select CPU_FREQ_GOV_SMARTMAX_EPS
	help
	  Use the CPUFreq governor 'smartmax eps' as default.

config CPU_FREQ_DEFAULT_GOV_SAKURACTIVE
	bool "sakuractive"
	select CPU_FREQ_GOV_SAKURACTIVE
	select CPU_FREQ_GOV_PERFORMANCE
	help
	  Use the CPUFreq governor 'sakuractive' as default. This allows you
	  to get a full dynamic frequency capable system with CPU
	  hotplug support by simply loading your cpufreq low-level
	  hardware driver.  Be aware that not all cpufreq drivers
	  support the hotplug governor. If unsure have a look at
	  the help section of the driver. Fallback governor will be the
	  performance governor.	  

config CPU_FREQ_DEFAULT_GOV_SCARY
	bool "scary"
	select CPU_FREQ_GOV_SCARY
	help
	  Use the CPUFreq governor 'scary' as default.

config CPU_FREQ_DEFAULT_GOV_SLIM
	bool "slim"
	select CPU_FREQ_GOV_SLIM
	select CPU_FREQ_GOV_PERFORMANCE
	help
	Use the CPUFreq governor 'slim' as default.
	
config CPU_FREQ_DEFAULT_GOV_SLP
	bool "slp"
	select CPU_FREQ_GOV_SLP
	help
	  Use the CPUFreq governor 'slp' as default.	

config CPU_FREQ_DEFAULT_GOV_SLEEPY
	bool "sleepy"
	select CPU_FREQ_GOV_SLEEPY
	help
	  Use the CPUFreq governor 'sleepy' as default.

config CPU_FREQ_DEFAULT_GOV_THUNDERX
  	bool "thunderx"
  	select CPU_FREQ_GOV_THUNDERX
  	help

config CPU_FREQ_DEFAULT_GOV_TRIPNDROID
	bool "tripndroid"
	select CPU_FREQ_GOV_TRIPNDROID
	help
	  Select tripndroid cpu governor as default	  
	  
config CPU_FREQ_DEFAULT_GOV_UBERDEMAND
	bool "uberdemand"
	select CPU_FREQ_GOV_UBERDEMAND
	select CPU_FREQ_GOV_PERFORMANCE
	help
	  Use the CPUFreq governor 'ondemand' as default. This allows
	  you to get a full dynamic frequency capable system by simply
	  loading your cpufreq low-level hardware driver.
	  Be aware that not all cpufreq drivers support the ondemand
	  governor. If unsure have a look at the help section of the
	  driver. Fallback governor will be the performance governor.
	  uberdemand has built in a second phase profile.
	  
config CPU_FREQ_DEFAULT_GOV_UMBRELLA_CORE
	bool "umbrella_core"
	select CPU_FREQ_GOV_UMBRELLA_CORE
	help
	  Use the CPUFreq governor 'umbrella_core' as default. This allows
	  you to get a full dynamic cpu frequency capable system by simply
	  loading your cpufreq low-level hardware driver, using the
	  'umbrella_core' governor for latency-sensitive workloads.	

config CPU_FREQ_DEFAULT_GOV_USERSPACE
	bool "userspace"
	select CPU_FREQ_GOV_USERSPACE
	help
	  Use the CPUFreq governor 'userspace' as default. This allows
	  you to set the CPU frequency manually or when a userspace 
	  program shall be able to set the CPU dynamically without having
	  to enable the userspace governor manually.

config CPU_FREQ_DEFAULT_GOV_WAVE
	bool "wave"
	select CPU_FREQ_GOV_WAVE
	help

config CPU_FREQ_DEFAULT_GOV_WHEATLEY
	bool "wheatley"
	select CPU_FREQ_GOV_WHEATLEY
	select CPU_FREQ_GOV_PERFORMANCE
	---help---
	  Use the CPUFreq governor 'wheatley' as default.

config CPU_FREQ_DEFAULT_GOV_XPERIENCE
	bool "xperience"
	select CPU_FREQ_GOV_XPERIENCE
	help
	Use the CPUfreq governor 'xperience' as default.

config CPU_FREQ_DEFAULT_GOV_YANKACTIVE
	bool "yankactive"
	select CPU_FREQ_GOV_YANKACTIVE
	help
	  Use the CPUFreq governor 'yankactive' as default. This allows
	  you to get a full dynamic cpu frequency capable system by simply
	  loading your cpufreq low-level hardware driver, using the
	  'yankactive' governor for latency-sensitive workloads.

config CPU_FREQ_DEFAULT_GOV_ZZMOOVE
	bool "zzmoove"
	select CPU_FREQ_GOV_ZZMOOVE
	select CPU_FREQ_GOV_PERFORMANCE
	help
	  Use the CPUFreq governor 'zzmoove' as default, using predefined
	  frequency lookup tables and optimized scaling triggers instead of
	  % frequency steps to get smooth up/downscaling dependant on CPU load.

config CPU_FREQ_DEFAULT_GOV_ZENX
	bool "ZenX"
	select CPU_FREQ_GOV_ZENX
	help
	  Use the CPUFreq governor 'ZenX' as default.

config CPU_FREQ_DEFAULT_GOV_THUNDERSTORMS
	bool "thunderstorms"
	select CPU_FREQ_GOV_THUNDERSTORMS
	help
	  Use the CPUFreq governor 'thunderstorms' as default. This allows
	  you to get a full dynamic cpu frequency capable system by simply
	  loading your cpufreq low-level hardware driver, using the
	  'thunderstorms' governor for latency-sensitive workloads.

endchoice

config CPU_FREQ_GOV_ABYSSPLUG
	tristate "'abyssplug' cpufreq governor"
	depends on CPU_FREQ && NO_HZ && HOTPLUG_CPU
	---help---
	  'abyssplug' - this driver mimics the frequency scaling behavior
	  in 'ondemand', but with several key differences.  First is
	  that frequency transitions use the CPUFreq table directly,
	  instead of incrementing in a percentage of the maximum
	  available frequency.  Second 'abyssplug' will offline auxillary
	  CPUs when the system is idle, and online those CPUs once the
	  system becomes busy again.  This last feature is needed for
	  architectures which transition to low power states when only
	  the "master" CPU is online, or for thermally constrained
	  devices.
	  If you don't have one of these architectures or devices, use
	  'ondemand' instead.
	  If in doubt, say N.

config CPU_FREQ_GOV_ABYSSPLUGV2
	tristate "'abyssplug' cpufreq governor"
	depends on CPU_FREQ && NO_HZ && HOTPLUG_CPU
	---help---
	  'abyssplugv2' - this driver mimics the frequency scaling behavior
	  in 'ondemand', but with several key differences.  First is
	  that frequency transitions use the CPUFreq table directly,
	  instead of incrementing in a percentage of the maximum
	  available frequency.  Second 'abyssplug' will offline auxillary
	  CPUs when the system is idle, and online those CPUs once the
	  system becomes busy again.  This last feature is needed for
	  architectures which transition to low power states when only
	  the "master" CPU is online, or for thermally constrained
	  devices.
	  If you don't have one of these architectures or devices, use
	  'ondemand' instead.
	  If in doubt, say N.

config CPU_FREQ_GOV_ADAPTIVE
	tristate "'adaptive' cpufreq policy governor"
	default n
	help
	  'adaptive' - This driver adds a dynamic cpufreq policy governor
	  designed for latency-sensitive workloads and also for demanding
	  performance.

	  This governor attempts to reduce the latency of clock
	  increases so that the system is more responsive to
	  interactive workloads in loweset steady-state but to
	  to reduce power consumption in middle operation level level up
	  will be done in step by step to prohibit system from going to
	  max operation level.

	  To compile this driver as a module, choose M here: the
	  module will be called cpufreq_adaptive.

	  For details, take a look at linux/Documentation/cpu-freq.

	  If in doubt, say N.

config CPU_FREQ_GOV_ADAPTIVEX
	tristate "'adaptiveX' cpufreq policy governor"
	help
	  'adaptive' with suspend/wake/hotplugging support.

config CPU_FREQ_GOV_ALUCARD
	tristate "'alucard' cpufreq governor"
	depends on CPU_FREQ

config CPU_FREQ_GOV_ARTERACTIVE
	tristate "'arteractive' cpufreq policy governor"
	help
	  'arteractive' - This driver adds the interactive governor
	  from the SM-G900F source drop.

config CPU_FREQ_GOV_ASSWAX
	tristate "'asswax' cpufreq governor"
	depends on CPU_FREQ
	help
	  Use as default governors
	  
config CPU_FREQ_GOV_BADASS
	tristate "'badass' cpufreq policy governor"
	select CPU_FREQ_TABLE
	help
	  'badass' - This driver adds a dynamic cpufreq policy governor.
	  The governor does a periodic polling and
	  changes frequency based on the CPU utilization.
	  The support for this governor depends on CPU capability to
	  do fast frequency switching (i.e, very low latency frequency	  transitions).
	  To compile this driver as a module, choose M here: the
	  module will be called cpufreq_badass.
	  If in doubt, say N.

config CONFIG_CPU_FREQ_GOV_BADASS_SECOND_PHASE_FREQ
	int "'badass' Second Phase Frequency"
	default 1497600
	depends on CPU_FREQ_GOV_BADASS	  

config CONFIG_CPU_FREQ_GOV_BADASS_THIRD_PHASE_FREQ
	int "'badass' Third Phase Frequency"
	default 1497600
	depends on CPU_FREQ_GOV_BADASS

config CPU_FREQ_GOV_BADASS_2_PHASE
	tristate "'2-phase' power-efficiency badass algorithm"
	depends on CPU_FREQ_GOV_BADASS
	help
	  '2-phase' - This driver adds a new algo to save power

config CPU_FREQ_GOV_BADASS_2_PHASE_FREQ
	int "'2-phase' badass frequency"
	default 1267200 
	depends on CPU_FREQ_GOV_BADASS
	depends on CPU_FREQ_GOV_BADASS_2_PHASE

config CPU_FREQ_GOV_BADASS_3_PHASE
	tristate "'3-phase' power-efficiency badass algorithm"
	depends on CPU_FREQ_GOV_BADASS
	depends on CPU_FREQ_GOV_BADASS_2_PHASE
	help
	  '3-phase' - This driver adds a new algo to save power

config CPU_FREQ_GOV_BADASS_3_PHASE_FREQ
	int "'3-phase' badass frequency"
	default 1497600
	depends on CPU_FREQ_GOV_BADASS
	depends on CPU_FREQ_GOV_BADASS_2_PHASE
	depends on CPU_FREQ_GOV_BADASS_3_PHASE

config CPU_FREQ_GOV_BADASS_GPU_CONTROL
	tristate "'gpu_control' power-efficiency badass algorithm"
	depends on CPU_FREQ_GOV_BADASS
	depends on CPU_FREQ_GOV_BADASS_2_PHASE
	help
	  'gpu_control' - This driver adds a new algo to save power

config CPU_FREQ_GOV_BADASS_LOWBAT_POWERSAVE
	tristate "'lowbat_powersave' power-efficiency badass algorithm"
	depends on CPU_FREQ_GOV_BADASS
	help
	  'lowbat_powersave' - This driver adds a new algo to save power

config CPU_FREQ_GOV_BADASS_ALLOW_BYPASS
	tristate "Allows bypassing phases"
	depends on CPU_FREQ_GOV_BADASS
	depends on CPU_FREQ_GOV_BADASS_2_PHASE
	help
	  'allow_bypass' - This driver adds a bypass to the phases

config CPU_FREQ_GOV_BALANCE
	tristate "'balance' cpufreq policy governor"
	select CPU_FREQ_TABLE
	help
	  'balance' - This driver adds a dynamic cpufreq policy governor.
	  The governor does a periodic polling and 
	  changes frequency based on the CPU utilization.
	  The support for this governor depends on CPU capability to
	  do fast frequency switching (i.e, very low latency frequency
	  transitions). 

	  To compile this driver as a module, choose M here: the
	  module will be called cpufreq_hotplug.

	  For details, take a look at linux/Documentation/cpu-freq.

	  If in doubt, say N.

config CPU_FREQ_GOV_BARRY_ALLEN
	tristate "'barry_allen' cpufreq policy governor"
	help
	  'barry_allen' - This driver adds a dynamic cpufreq policy governor
	  designed for latency-sensitive workloads.

	  This governor attempts to reduce the latency of clock
	  increases so that the system is more responsive to
	  barry_allen workloads.

	  To compile this driver as a module, choose M here: the
	  module will be called cpufreq_barry_allen.

	  For details, take a look at linux/Documentation/cpu-freq.

	  If in doubt, say N.

config CPU_FREQ_GOV_BIOSHOCK
	tristate "'bioshock' cpufreq bioshock"
	depends on CPU_FREQ
	help
	  'bioshock' - More aggressive version of conservative

config CPU_FREQ_GOV_BLU_ACTIVE
	tristate "'blu_active' cpufreq policy governor"
	help
	  'blu_active' - This driver adds a dynamic cpufreq policy governor
	  interactive workloads.

	  To compile this driver as a module, choose M here: the
	  module will be called cpufreq_blu_active.
	  designed for latency-sensitive workloads.

config CPU_FREQ_GOV_BLU_SCHEDUTIL
	tristate "'blu_schedutil' cpufreq policy governor"
	depends on CPU_FREQ
	select CPU_FREQ_GOV_ATTR_SET
	select IRQ_WORK
	help
	  This governor makes decisions based on the utilization data provided
	  by the scheduler.  It sets the CPU frequency to be proportional to
	  the utilization/capacity ratio coming from the scheduler.  If the
	  utilization is frequency-invariant, the new frequency is also
	  proportional to the maximum available frequency.  If that is not the
	  case, it is proportional to the current frequency of the CPU.  The
	  frequency tipping point is at utilization/capacity equal to 80% in
	  both cases.

 	  To compile this driver as a module, choose M here: the module will
	  be called cpufreq_blu_schedutil.

 	  If in doubt, say N.

config CPU_FREQ_GOV_BOOSTACTIVE
	tristate "'boostactive' cpufreq policy governor"
	help
	  'boostactive' - This driver adds a dynamic cpufreq policy governor
	  designed for latency-sensitive workloads.

	  This governor attempts to reduce the latency of clock
	  increases so that the system is more responsive to
	  interactive workloads.

	  To compile this driver as a module, choose M here: the
	  module will be called cpufreq_interactive.

	  For details, take a look at linux/Documentation/cpu-freq.

	  If in doubt, say N.
	  
config CPU_FREQ_GOV_BRAZILIANWAX
	tristate "'brazilianwax' cpufreq governor"
	depends on CPU_FREQ
	help
          'brazilianwax' - a "slightly more agressive smart" optimized governor!

	  If in doubt, say N.

config CPU_FREQ_GOV_CAFACTIVE
	tristate "'cafactive' cpufreq policy governor"
	help
	  'cafactive' - CodeAurora(Qualcomm) version of interactive
	  cpufreq policy governor.

	  To compile this driver as a module, choose M here: the
	  module will be called cpufreq_cafactive.

	  If in doubt, say N.

config CPU_FREQ_GOV_CHILL
	tristate "'chill' cpufreq governor"
	depends on CPU_FREQ
	select CPU_FREQ_GOV_COMMON
	default y
	help
	  'chill' - similar to 'conservative', but optimized for devices
	  that go into suspended or display off states often.

config CPU_FREQ_GOV_CLARITY
	bool "'clarity' cpufreq policy governor"
	help
	  'clarity' - This driver adds a dynamic cpufreq policy governor
	  designed for latency-sensitive workloads.

	  If in doubt, say N.

config CPU_FREQ_GOV_CONSERVATIVE
	tristate "'conservative' cpufreq governor"
	depends on CPU_FREQ
	select CPU_FREQ_GOV_COMMON
	help
	  'conservative' - this driver is rather similar to the 'ondemand'
	  governor both in its source code and its purpose, the difference is
	  its optimisation for better suitability in a battery powered
	  environment.  The frequency is gracefully increased and decreased
	  rather than jumping to 100% when speed is required.

	  If you have a desktop machine then you should really be considering
	  the 'ondemand' governor instead, however if you are using a laptop,
	  PDA or even an AMD64 based computer (due to the unacceptable
	  step-by-step latency issues between the minimum and maximum frequency
	  transitions in the CPU) you will probably want to use this governor.

	  To compile this driver as a module, choose M here: the
	  module will be called cpufreq_conservative.

	  For details, take a look at linux/Documentation/cpu-freq.

	  If in doubt, say N.
	  
config CPU_FREQ_GOV_CULTIVATION
	tristate "'cultivation' cpufreq governor"
	depends on CPU_FREQ
	help
	  'cultivation' - another tuned interactive with extra options

config CPU_FREQ_GOV_CYAN
	tristate "'cyan' cpufreq governor"
	depends on CPU_FREQ
	help
		CYAN

config CPU_FREQ_GOV_DANCEDANCE
           tristate "'dancedance' cpufreq governor"
           depends on CPU_FREQ
           help
             dancedance' - a "smart" optimized governor!
             If in doubt, say N.

config CPU_FREQ_GOV_DARKNESS
	tristate "'darkness' cpufreq governor"
	depends on CPU_FREQ

config CPU_FREQ_GOV_DESPAIR
	tristate "'despair' cpufreq governor"
	depends on CPU_FREQ

config CPU_FREQ_GOV_ELECTRODEMAND
	tristate "'electrodemand' cpufreq policy governor"
        depends on CPU_FREQ
	help
	  'electrodemand' - A tweaked "ondemand" based smart and smooth optimized
           governor designed for optimization in transition and a balance between
           performance and power.
	
	   If in doubt, say N.

config CPU_FREQ_GOV_ELECTRON
	tristate "'electron' cpufreq governor"
	depends on CPU_FREQ
	help
	  'electron' - another tuned interactive with extra options

config CPU_FREQ_GOV_ELEMENTALX
	tristate "'elementalx' cpufreq policy governor"
	select CPU_FREQ_TABLE
	help
	  'elementalx' - This driver adds a dynamic cpufreq policy governor.

	  To compile this driver as a module, choose M here: the
	  module will be called cpufreq_elementalx.

	  For details, take a look at linux/Documentation/cpu-freq.

	  If in doubt, say N.

config CPU_FREQ_GOV_HOTPLUG
	tristate "'hotplug' cpufreq policy governor"
	select CPU_FREQ_TABLE
	select CPU_FREQ_GOV_COMMON
	help
	  'hotplug' - This driver adds a dynamic cpufreq policy governor.
	  The governor does a periodic polling and
	  changes frequency based on the CPU utilization.
	  The support for this governor depends on CPU capability to
	  do fast frequency switching (i.e, very low latency frequency
	  transitions).

	  To compile this driver as a module, choose M here: the
	  module will be called cpufreq_hotplug.

	  For details, take a look at linux/Documentation/cpu-freq.

	  If in doubt, say N.

config CPU_FREQ_GOV_HYPER
	tristate "'HYPER' cpufreq governor"
	depends on CPU_FREQ
	---help---
	  'HYPER' - a tweaked "ondemand" based smart and smooth optimized governor!

	  If in doubt, say Y.

config CPU_FREQ_GOV_HYPERX
        tristate "'HYPERX' cpufreq governor"
        depends on CPU_FREQ
        ---help---
          'HYPERX' - a tweaked "ondemand" based smart and smooth optimized governor!

           If in doubt, say Y.

config CPU_FREQ_GOV_INTEL
	tristate "'intel' cpufreq policy governor"
	help
	  'intel' - This driver adds a dynamic cpufreq policy governor
	  designed for Intel mobile platform.

	  This governor uses physical core load, dynamic timer switching,
	  dynamic sampling window sizing, and tailored CPU frequency scaling,
	  which brings good performance, power efficiency and responsiveness
	  to common Android applications with Intel mobile platforms.

	  To compile this driver as a module, choose M here: the
	  module will be called cpufreq_intel.

config CPU_FREQ_GOV_HOTPLUG
	tristate "'hotplug' cpufreq governor"
	select CPU_FREQ_TABLE
	help
	  'hotplug' - this driver mimics the frequency scaling behavior
	  in 'ondemand', but with several key differences.  First is
	  that frequency transitions use the CPUFreq table directly,
	  instead of incrementing in a percentage of the maximum
	  available frequency.  Second 'hotplug' will offline auxillary
	  CPUs when the system is idle, and online those CPUs once the
	  system becomes busy again.  This last feature is needed for
	  architectures which transition to low power states when only
	  the "master" CPU is online, or for thermally constrained
	  devices.

	  If you don't have one of these architectures or devices, use
	  'ondemand' instead.

	  If in doubt, say N

config CPU_FREQ_GOV_IMPULSE
	tristate "'interactive' cpufreq policy governor"
	help
		'impulse' - This driver adds a dynamic cpufreq policy governor
		designed for latency-sensitive workloads.

		If in doubt, say N.

config CPU_FREQ_GOV_NEBULA
	tristate "'nebula' cpufreq policy governor"


config CPU_FREQ_GOV_INTELLIACTIVE
	tristate "'intelliactive' cpufreq policy governor"
	help
	  'intelliactive' - This driver adds a dynamic cpufreq policy governor
	  designed for latency-sensitive workloads.

	  This governor attempts to reduce the latency of clock
	  increases so that the system is more responsive to
	  interactive workloads.

	  To compile this driver as a module, choose M here: the
	  module will be called cpufreq_interactive.

	  For details, take a look at linux/Documentation/cpu-freq.

	  If in doubt, say N.

config CPU_FREQ_GOV_INTELLIDEMAND
        tristate "'intellidemand' cpufreq policy governor"
        select CPU_FREQ_TABLE
        help
          'intellidemand' - This driver adds a dynamic cpufreq policy governor.
          The governor does a periodic polling and
          changes frequency based on the CPU utilization.
          The support for this governor depends on CPU capability to
          do fast frequency switching (i.e, very low latency frequency
          transitions). with browsing detection based on GPU loading

          To compile this driver as a module, choose M here: the
          module will be called cpufreq_ondemand.

          For details, take a look at linux/Documentation/cpu-freq.

          If in doubt, say N.

config CPU_FREQ_GOV_INTELLIMM
       tristate "'intelliminmax' cpufreq policy governor"
       help
         To compile this driver as a module, choose M here: the
         module will be called cpufreq_interactive.

         For details, take a look at linux/Documentation/cpu-freq.

         If in doubt, say N.

config CPU_FREQ_GOV_INTERACTIVE
	tristate "'interactive' cpufreq policy governor"
	help
	  'interactive' - This driver adds a dynamic cpufreq policy governor
	  designed for latency-sensitive workloads.

	  This governor attempts to reduce the latency of clock
	  increases so that the system is more responsive to
	  interactive workloads.

	  To compile this driver as a module, choose M here: the
	  module will be called cpufreq_interactive.

	  For details, take a look at linux/Documentation/cpu-freq.

	  If in doubt, say N.

config CPU_FREQ_GOV_INTERACTIVEB
	tristate "'interactiveb' cpufreq policy governor"

config CPU_FREQ_GOV_DYNAMIC_INTERACTIVE
	tristate "'dynamic_interactive' cpufreq policy governor"
	depends on CPU_FREQ

config CPU_FREQ_GOV_THUNDERSTORMS_INTERACTIVE
	tristate "'thunderstorms_interactive' cpufreq policy governor"
	depends on CPU_FREQ

config CPU_FREQ_GOV_THUNDERSTORM
	tristate "'thunderstorm' cpufreq policy governor"
	depends on CPU_FREQ

config CPU_FREQ_GOV_IRONACTIVE
	tristate "'ironactive' cpufreq policy governor"
	help
	  'ironactive' - This driver adds a dynamic cpufreq policy governor
	  designed for latency-sensitive workloads.

	  This governor attempts to reduce the latency of clock
	  increases so that the system is more responsive to
	  interactive workloads.

	  For details, take a look at linux/Documentation/cpu-freq.

	  If in doubt, say N.

config CPU_FREQ_GOV_FRANKENSTEIN
	tristate "'frankenstein' cpufreq policy governor"
	help
	  'frankenstein' - Modified version of interactive with sleep+wake code.

config CPU_FREQ_GOV_HYBRID
	tristate "'hybrid' cpufreq policy governor"
	select CPU_FREQ_TABLE
	help
	  'hybrid' - This driver adds a dynamic cpufreq policy governor.
	  The governor does a periodic polling and 
	  changes frequency based on the CPU utilization.
	  The support for this governor depends on CPU capability to
	  do fast frequency switching (i.e, very low latency frequency
	  transitions). 

	  To compile this driver as a module, choose M here: the
	  module will be called cpufreq_hybrid.

	  For details, take a look at linux/Documentation/cpu-freq.

	  If in doubt, say N.

config CPU_FREQ_GOV_FRANKENSTEIN
	tristate "'frankenstein' cpufreq policy governor"
	help
	  'frankenstein' - Modified version of interactive with sleep+wake code.

config CPU_FREQ_GOV_KTOONSERVATIVEQ
	tristate "'ktoonservativeq' cpufreq governor"
	depends on CPU_FREQ
	help
	  'ktoonservativeq' - this driver is rather similar to the 'ondemand'
	  governor both in its source code and its purpose, the difference is
	  its optimisation for better suitability in a battery powered
	  environment.  The frequency is gracefully increased and decreased
	  rather than jumping to 100% when speed is required.

	  If you have a desktop machine then you should really be considering
	  the 'ondemand' governor instead, however if you are using a laptop,
	  PDA or even an AMD64 based computer (due to the unacceptable
	  step-by-step latency issues between the minimum and maximum frequency
	  transitions in the CPU) you will probably want to use this governor.
	  This governor adds the capability of hotpluging.

	  To compile this driver as a module, choose M here: the
	  module will be called cpufreq_ktoonservativeq.

	  For details, take a look at linux/Documentation/cpu-freq.

	  If in doubt, say N.

############# LAGFREE #################
config CPU_FREQ_GOV_LAGFREE
        tristate "'lagfree' cpufreq governor"
        depends on CPU_FREQ
        default y
        help
          'lagfree' - this driver is rather similar to the 'ondemand'
          governor both in its source code and its purpose, the difference is
          its optimisation for better suitability in a battery powered
          environment.  The frequency is gracefully increased and decreased
          rather than jumping to 100% when speed is required.

config LAGFREE_MAX_LOAD
	int "Max CPU Load"
	default 50
	depends on CPU_FREQ_GOV_LAGFREE
	help
	  CPU freq will be increased if measured load > max_cpu_load;

config LAGFREE_MIN_LOAD
	int "Min CPU Load"
	default 15
	depends on CPU_FREQ_GOV_LAGFREE
	help
	  CPU freq will be decrease if measured load < min_cpu_load;

config LAGFREE_FREQ_STEP_DOWN
	int "Frequency Step Down"
	default 256000
	depends on CPU_FREQ_GOV_LAGFREE
	help
	  Max freqeuncy delta when ramping down.

config LAGFREE_FREQ_SLEEP_MAX
	int "Max Sleep frequeny"
	default 300000
	depends on CPU_FREQ_GOV_LAGFREE
	help
	  Max freqeuncy for screen off.

config LAGFREE_FREQ_AWAKE_MIN
	int "Min Awake frequeny"
	default 300000
	depends on CPU_FREQ_GOV_LAGFREE
	help
	  Min freqeuncy for screen on.

config LAGFREE_FREQ_STEP_UP_SLEEP_PERCENT
	int "Freq step up percent sleep"
	default 20
	depends on CPU_FREQ_GOV_LAGFREE
	help
	  Frequency percent to step up while screen off.
#################################################################

config CPU_FREQ_GOV_LIONFISH
	tristate "'lionfish' governor"
	depends on CPU_FREQ
	help
	  'lionfish' - this is an improved version of the conservative governor
	  that is optimized for smartphones. To avoid lag, it quickly jumps
	  to an intermediate frequency when high load is encountered at low
	  frequencies. If very high load is encountered above this intermediate
	  frequency, it jumps to a high frequency. For moderate loads, it
	  votes to increase, decrease, or maintain frequencies at each sampling
	  interval. When enough votes are gathered to raise or lower the
	  frequency, the frequency is changed. This mechanism reduces jitter
	  compared to the conservative governor. Lionfish uses proportional
	  ramping to more quickly reach suitable frequencies compared to the
	  conservative governor. By default, Lionfish also reduces frequencies
	  more aggressively than the conservative governor when loads are reduced.

	  To compile this driver as a module, choose M here: the
	  module will be called cpufreq_lionfish.

	  If in doubt, say N.

config CPU_FREQ_GOV_LAZY
	tristate "'lazy' cpufreq governor"
	depends on CPU_FREQ
	help
	  Use the CPUFreq governor 'lazy'.

config CPU_FREQ_GOV_LIONHEART
	tristate "'lionheart' cpufreq governor"
	depends on CPU_FREQ
	help
	  lionheart' - a "smart" optimized governor!
	  If in doubt, say N.

config CPU_FREQ_GOV_LULZACTIVE
	tristate "'lulzactive' cpufreq governor"
	depends on CPU_FREQ
	help
	  'lulzactive' - a new interactive governor by Tegrak!
	  For more information please visit:
	  http://tegrak2x.blogspot.com/2011/11/lulzactive-governor-v2.html

	  If in doubt, say N.	  

config CPU_FREQ_GOV_MYTHX_PLUG
	tristate "'mythx_plug' cpufreq governor"
	depends on CPU_FREQ

config CPU_FREQ_GOV_NEXUS
	tristate "'nexus' cpufreq policy governor"
	help
	  Compile the CPUFreq governor 'nexus'.

	  To compile this driver as a module, choose M here: the
	  module will be called cpufreq_interactive.

	  For details, take a look at linux/Documentation/cpu-freq.

	  If in doubt, say N.

config CPU_FREQ_GOV_NIGHTMARE
	tristate "'nightmare' cpufreq governor"
	depends on CPU_FREQ

config CPU_FREQ_GOV_ONDEMAND
	tristate "'ondemand' cpufreq policy governor"
	select CPU_FREQ_GOV_COMMON
	help
	  'ondemand' - This driver adds a dynamic cpufreq policy governor.
	  The governor does a periodic polling and 
	  changes frequency based on the CPU utilization.
	  The support for this governor depends on CPU capability to
	  do fast frequency switching (i.e, very low latency frequency
	  transitions). 

	  To compile this driver as a module, choose M here: the
	  module will be called cpufreq_ondemand.

	  For details, take a look at linux/Documentation/cpu-freq.

	  If in doubt, say N.

config CPU_FREQ_GOV_ONDEMANDPLUS
	tristate "'ondemandplus' cpufreq policy governor"
	select CPU_FREQ_TABLE
	help
	  'ondemandplus' - This driver adds a dynamic cpufreq policy
	  governor. The governor does a periodic polling and
	  changes frequency based on the CPU utilization.
	  The support for this governor depends on CPU capability to
	  do fast frequency switching (i.e, very low latency frequency
	  transitions).
	  To compile this driver as a module, choose M here: the
	  module will be called cpufreq_ondemandplus.
	  For details, take a look at linux/Documentation/cpu-freq.
	  If in doubt, say N.

config CPU_FREQ_GOV_ONDEMAND_X
	tristate "'ondemand_x' cpufreq policy governor"
	select CPU_FREQ_TABLE
	help
	  'ondemand_x' - This driver adds a dynamic cpufreq policy governor.
	  The governor does a periodic polling and 
	  changes frequency based on the CPU utilization.
	  The support for this governor depends on CPU capability to
	  do fast frequency switching (i.e, very low latency frequency
	  transitions). 

	  To compile this driver as a module, choose M here: the
	  module will be called cpufreq_ondemand_x.

	  For details, take a look at linux/Documentation/cpu-freq.

	  If in doubt, say N.

config CPU_FREQ_GOV_OPTIMAX
	tristate "'optimax' cpufreq policy governor"
	select CPU_FREQ_TABLE

config CPU_FREQ_GOV_PEGASUSQ
	tristate "'pegasusq' cpufreq policy governor"

config CPU_FREQ_GOV_PERFORMANCE
	tristate "'performance' governor"
	help
	  This cpufreq governor sets the frequency statically to the
	  highest available CPU frequency.

	  To compile this driver as a module, choose M here: the
	  module will be called cpufreq_performance.

	  If in doubt, say Y.

config CPU_FREQ_GOV_POISON
   tristate "'Poison' cpufreq governor"
   depends on CPU_FREQ
   help
   'Poison' - a "power optimized" governor

config CPU_FREQ_GOV_POWERSAVE
	tristate "'powersave' governor"
	help
	  This cpufreq governor sets the frequency statically to the
	  lowest available CPU frequency.

	  To compile this driver as a module, choose M here: the
	  module will be called cpufreq_powersave.

	  If in doubt, say Y.

config CPU_FREQ_GOV_PRESERVATIVE
	tristate "'preservative' cpufreq governor"
	depends on CPU_FREQ
	help
	  'preservative' - this driver is good in cakes

	  If in doubt, say N.	
	  
config CPU_FREQ_GOV_RAGINGMOLASSES
	tristate "'RAGINGMOLASSES' cpufreq policy governor"
	help
	  'RAGINGMOLASSES' - This driver adds a cpufreq policy governor 
	  much along the lines of ondemand but tries to keep to low 
	  frequencies without hurting performance for workloads that need it.
	  To compile this driver as a module, choose M here: the
	  module will be called cpufreq_interactive.

	  For details, take a look at linux/Documentation/cpu-freq.

	  If in doubt, say N0.	  	  
	  
config CPU_FREQ_GOV_SAKURACTIVE
	tristate "'sakuractive' cpufreq governor"
	depends on CPU_FREQ && NO_HZ && HOTPLUG_CPU
	help
	  'sakuractive' - this driver mimics the frequency scaling behavior
	  in 'ondemand', but with several key differences.  First is
	  that frequency transitions use the CPUFreq table directly,
	  instead of incrementing in a percentage of the maximum
	  available frequency.  Second 'sakuractive' will offline auxillary
	  CPUs when the system is idle, and online those CPUs once the
	  system becomes busy again.  This last feature is needed for
	  architectures which transition to low power states when only
	  the "master" CPU is online, or for thermally constrained
	  devices.

	  If you don't have one of these architectures or devices, use
	  'ondemand' instead.

	  If in doubt, say N.	  

config CPU_FREQ_GOV_SLIM
	tristate "'slim' cpufreq policy governor"
	select CPU_FREQ_TABLE
	help
	  'slim' - This driver adds a dynamic cpufreq policy governor.

	  To compile this driver as a module, choose M here: the
	  module will be called cpufreq_slim.

	  For details, take a look at linux/Documentation/cpu-freq.

config CPU_FREQ_GOV_SAVAGEDZEN
	tristate "'savagedzen' cpufreq policy governor"

config CPU_FREQ_GOV_SLP
	tristate "'slp' cpufreq policy governor"

config CPU_FREQ_GOV_SLEEPY
	tristate "'sleepy' cpufreq policy governor"

config CPU_FREQ_GOV_SCARY
	tristate "'scary' cpufreq policy governor"

config CPU_FREQ_GOV_RELAXED
	tristate "'relaxed' cpufreq governor"
	depends on CPU_FREQ
	select CPU_FREQ_GOV_COMMON
	default y
	help
		'relaxed' - similar to 'conservative', but optimized for devices
		that go into suspended or display off states often.

config CPU_FREQ_GOV_SCHED
	bool "'sched' cpufreq governor"
	depends on CPU_FREQ
	depends on SMP
	select CPU_FREQ_GOV_COMMON
	help
	  'sched' - this governor scales cpu frequency from the
	  scheduler as a function of cpu capacity utilization. It does
	  not evaluate utilization on a periodic basis (as ondemand
	  does) but instead is event-driven by the scheduler.

	  If in doubt, say N.

config CPU_FREQ_GOV_SMARTASS2
	tristate "'smartassV2' cpufreq governor"
	depends on CPU_FREQ
	help
	  'smartassV2' - a "smart" govern

config CPU_FREQ_GOV_SMARTMAX
	tristate "'smartmax' cpufreq governor"
	depends on CPU_FREQ
	help
	  'smartmax' - a "smart" optimized governor!
	  If in doubt, say N.

config CPU_FREQ_GOV_SMARTMAX_EPS
	tristate "'smartmax EPS' cpufreq policy governor"
	select CPU_FREQ_TABLE
	help
	  'smartmax EPS' is the extreme powersaving version of smartmax

config CPU_FREQ_GOV_SMARTASSH3
	tristate "'smartassH3' cpufreq governor"
	depends on CPU_FREQ
	help
    		'smartassH3' - a "smart" governor

config CPU_FREQ_GOV_TRIPNDROID
        tristate "'tripndroid' cpufreq governor"
        depends on CPU_FREQ
        help
	  Custom cpu governor designed specificly for multi cpu mobile devices.
	  Aiming at a balance between performance and battery lifetime, but it
	  hangs a little bit more towards performance at low latencys.
		  	  	
config CPU_FREQ_GOV_THESSJACTIVE
	tristate "'thessjactive' cpufreq policy governor"
	depends on CPU_FREQ	
	help
	credits to TheSSJ

config CPU_FREQ_GOV_UBERDEMAND
	tristate "'uberdemand' cpufreq policy governor"
	select CPU_FREQ_TABLE
	help
	  'uberdemand' - This driver adds a dynamic cpufreq policy governor.
	  The governor does a periodic polling and
	  changes frequency based on the CPU utilization.
	  The support for this governor depends on CPU capability to
	  do fast frequency switching (i.e, very low latency frequency
	  transitions).

config CPU_FREQ_GOV_UBERDEMAND_SECOND_PHASE_FREQ
	int "'uberdemand' Second Phase Frequency"
	default 1728000
	depends on CPU_FREQ_GOV_UBERDEMAND
	
config CPU_FREQ_GOV_UMBRELLA_CORE
	tristate "'umbrella_core' cpufreq policy governor"

config CPU_FREQ_GOV_THUNDERX
        tristate "'thunderx' cpufreq governor"
        depends on CPU_FREQ
        default n
        help
          'thunderx' - a "power optimized" governor

config CPU_FREQ_GOV_THESSJACTIVE
	tristate "'thessjactive' cpufreq policy governor"
	depends on CPU_FREQ	
	help
	credits to TheSSJ

config CPU_FREQ_GOV_WAVE
	tristate "'wave' cpufreq governor"
	depends on CPU_FREQ
	help

config CPU_FREQ_GOV_WHEATLEY
	tristate "'wheatley' cpufreq governor"
	depends on CPU_FREQ	

config CPU_FREQ_GOV_XPERIENCE
	 tristate "'xperience' cpufreq governor"
	 depends on CPU_FREQ
	 help
	'XPerience' - a "powered and smart" governor

config CPU_FREQ_GOV_USERSPACE
	tristate "'userspace' governor for userspace frequency scaling"
	help
	  Enable this cpufreq governor when you either want to set the
	  CPU frequency manually or when a userspace program shall
	  be able to set the CPU dynamically, like on LART 
	  <http://www.lartmaker.nl/>.

	  To compile this driver as a module, choose M here: the
	  module will be called cpufreq_userspace.

	  For details, take a look at <file:Documentation/cpu-freq/>.

	  If in doubt, say Y.

config CPU_FREQ_GOV_YANKACTIVE
	tristate "'yankactive' cpufreq policy governor"
	help
	  'yankactive' - This driver adds a dynamic cpufreq policy governor
	  designed for latency-sensitive workloads.

	  The governor is based on interactive with just different default settings
	  and can be achieved using interactive with a script. This is added for
	  simplification purposes for myself.

config CPU_FREQ_GOV_ZZMOOVE
	tristate "'zzmoove' cpufreq governor"
	depends on CPU_FREQ
	help
	  'zzmoove' - based on cpufreq_conservative, using predefined
	  frequency lookup tables and optimized scaling triggers instead of
	  % frequency steps to get smooth up/downscaling dependant on CPU load.
	  If in doubt, say N.

config CPU_FREQ_GOV_ZENX
	tristate "'ZenX' cpufreq governor"
	depends on CPU_FREQ
	help
	  'ZenX' - an interactive-based governor

config CPU_FREQ_GOV_SKYWALKER
	tristate "'skywalker' cpufreq governor"
	depends on CPU_FREQ
	help
	  'skywalker' - an interactive-based governor

config CPU_FREQ_GOV_THUNDERSTORMS
	tristate "'thunderstorms' cpufreq policy governor"
	help
	  'thunderstorms' - This driver adds a dynamic cpufreq policy governor
	  designed for latency-sensitive workloads.

	  This governor attempts to reduce the latency of clock
	  increases so that the system is more responsive to
	  modified interactive workloads.

	  To compile this driver as a module, choose M here: the
	  module will be called cpufreq_thunderstorms.

	  For details, take a look at linux/Documentation/cpu-freq.

	  If in doubt, say N.

config CPU_FREQ_GOV_SCHEDUTIL
	bool "'schedutil' cpufreq policy governor"
	depends on CPU_FREQ && SMP
	select CPU_FREQ_GOV_ATTR_SET
	select IRQ_WORK
	help
	  This governor makes decisions based on the utilization data provided
	  by the scheduler.  It sets the CPU frequency to be proportional to
	  the utilization/capacity ratio coming from the scheduler.  If the
	  utilization is frequency-invariant, the new frequency is also
	  proportional to the maximum available frequency.  If that is not the
	  case, it is proportional to the current frequency of the CPU.  The
	  frequency tipping point is at utilization/capacity equal to 80% in
	  both cases.

	  If in doubt, say N.

comment "CPU frequency scaling drivers"

config CPUFREQ_DT
	tristate "Generic DT based cpufreq driver"
	depends on HAVE_CLK && OF
	# if CPU_THERMAL is on and THERMAL=m, CPUFREQ_DT cannot be =y:
	depends on !CPU_THERMAL || THERMAL
	select PM_OPP
	help
	  This adds a generic DT based cpufreq driver for frequency management.
	  It supports both uniprocessor (UP) and symmetric multiprocessor (SMP)
	  systems which share clock and voltage across all CPUs.

	  If in doubt, say N.

config CPU_BOOST
	tristate "Event base short term CPU freq boost"
	depends on CPU_FREQ
	help
	  This driver boosts the frequency of one or more CPUs based on
	  various events that might occur in the system. As of now, the
	  events it reacts to are:
	  - Migration of important threads from one CPU to another.

	  If in doubt, say N.

config FINGERPRINT_BOOST
	bool "Fingerprint Boost"
	default y
	help
	  Boosts available CPUs to max frequency on fingerprint sensor input.

config CPU_INPUT_BOOST
	bool "CPU Input Boost"
	help
	  Boosts the CPU on touchscreen and touchpad input. Boost frequencies and
	  durations are calculated automatically.

config CPU_FREQ_GOV_SCHED
	bool "'sched' cpufreq governor"
	depends on CPU_FREQ
	depends on SMP
	select CPU_FREQ_GOV_COMMON
	help
	  'sched' - this governor scales cpu frequency from the
	  scheduler as a function of cpu capacity utilization. It does
	  not evaluate utilization on a periodic basis (as ondemand
	  does) but instead is event-driven by the scheduler.

	  If in doubt, say N.


menu "x86 CPU frequency scaling drivers"
depends on X86
source "drivers/cpufreq/Kconfig.x86"
endmenu

menu "ARM CPU frequency scaling drivers"
depends on ARM || ARM64
source "drivers/cpufreq/Kconfig.arm"
endmenu

menu "AVR32 CPU frequency scaling drivers"
depends on AVR32

config AVR32_AT32AP_CPUFREQ
	bool "CPU frequency driver for AT32AP"
	depends on PLATFORM_AT32AP
	default n
	help
	  This enables the CPU frequency driver for AT32AP processors.
	  If in doubt, say N.

endmenu

menu "CPUFreq processor drivers"
depends on IA64

config IA64_ACPI_CPUFREQ
	tristate "ACPI Processor P-States driver"
	depends on ACPI_PROCESSOR
	help
	This driver adds a CPUFreq driver which utilizes the ACPI
	Processor Performance States.

	For details, take a look at <file:Documentation/cpu-freq/>.

	If in doubt, say N.

endmenu

menu "MIPS CPUFreq processor drivers"
depends on MIPS

config LOONGSON2_CPUFREQ
	tristate "Loongson2 CPUFreq Driver"
	help
	  This option adds a CPUFreq driver for loongson processors which
	  support software configurable cpu frequency.

	  Loongson2F and it's successors support this feature.

	  For details, take a look at <file:Documentation/cpu-freq/>.

	  If in doubt, say N.

endmenu

menu "PowerPC CPU frequency scaling drivers"
depends on PPC32 || PPC64
source "drivers/cpufreq/Kconfig.powerpc"
endmenu

menu "SPARC CPU frequency scaling drivers"
depends on SPARC64
config SPARC_US3_CPUFREQ
	tristate "UltraSPARC-III CPU Frequency driver"
	help
	  This adds the CPUFreq driver for UltraSPARC-III processors.

	  For details, take a look at <file:Documentation/cpu-freq>.

	  If in doubt, say N.

config SPARC_US2E_CPUFREQ
	tristate "UltraSPARC-IIe CPU Frequency driver"
	help
	  This adds the CPUFreq driver for UltraSPARC-IIe processors.

	  For details, take a look at <file:Documentation/cpu-freq>.

	  If in doubt, say N.
endmenu

menu "SH CPU Frequency scaling"
depends on SUPERH
config SH_CPU_FREQ
	tristate "SuperH CPU Frequency driver"
	help
	  This adds the cpufreq driver for SuperH. Any CPU that supports
	  clock rate rounding through the clock framework can use this
	  driver. While it will make the kernel slightly larger, this is
	  harmless for CPUs that don't support rate rounding. The driver
	  will also generate a notice in the boot log before disabling
	  itself if the CPU in question is not capable of rate rounding.

	  For details, take a look at <file:Documentation/cpu-freq>.

	  If unsure, say N.
endmenu

endif
endmenu
